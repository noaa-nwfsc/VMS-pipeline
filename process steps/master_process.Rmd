---
title: "Step by Step VMS Processing"
author: "Owen Liu"
date: Last Run "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
---

```{r setup}
library(knitr)
library(here)
```

# Master VMS and Fish Ticket Processing Workflow

This document collates all individual steps of VMS/Fish Ticket processing for a chosen year.

```{r timer, include=FALSE}
alltime <- proc.time()
```

## Choose Fishery

Indicate the PacFIN codes for the fish ticket species you are interested in tracking, as well as the gears. Landings and revenue for these species and gears will be tracked in the pipeline, for both targeted and non-targeted trips. Keep in mind that although the pipeline will record all species that are landed on each fish ticket, exact landings and revenues for these species will ONLY be reported if they are included in `spp_codes`. Likewise, `gear_codes` should be thought of NOT as a filter on which gears you get out of the pipeline, but rather as all of the gear types for which you would like total revenue and landings, regardless of target species.

```{r}
spp_codes <- c("DOVR") # All of the species for which you want specific revenue and landings by ticket
# spp_codes_name <- "DCRB_CHNK"
# here's your options
#https://pacfin.psmfc.org/pacfin_pub/data_rpts_pub/code_lists/sp.txt
# gear_codes <- c("SHELLFISH POT (CRAB)","CRAB OR LOBSTER POT","CRAB POT","CRAB RING") ## gear types for Dungeness 
gear_codes <- c("BALLOON TRAWL","BEAM TRAWL","bottom trawl - mud(sole) gear","bottom trawl - roller gear","DANISH/SCOTTISH SEINE (TRAWL)","GROUNDFISH TRAWL","GROUNDFISH TRAWL, SMALL FOOTROPE (< 8 in.)","GROUNDFISH(OTTER) TRAWL","OTTER TRAWL","PAIR TRAWL","PARANZELLA","ROLLER TRAWL","SELECTIVE FLATFISH TRAWL","SELECTIVE FLATFISH TRAWL, SMALL FOOTROPE","TRAWL NET","TRAWL, FOOTROPE GREATER THAN 8 INCHES IN DIAMETER","TRAWL, FOOTROPE LESS THAN 8 INCHES IN DIAMETER")
# All of the gears for which you want total revenue and landings by ticket
# As implemented, these are the full names (i.e., the "AGENCY DESCRIPTION" column of the table linked here, e.g. "CRAB POT", not "CPT")
# https://pacfin.psmfc.org/pacfin_pub/data_rpts_pub/code_lists/agency_gears.txt
```

Indicate the metric to use in determining targets of fishing trips, as well as the threshold for determining the target of each fishing trip.

```{r}
# choose landing and revenue metrics
pacfin_weight_metric <- "LANDED_WEIGHT_LBS" # another option is "LANDED_WEIGHT_MTONS"
pacfin_revenue_metric <- "EXVESSEL_REVENUE" # another option is AFI_EXVESSEL_REVENUE
# target_metric <- "revenue" # afi_revenue is an alternative option for newer fish tickets, but use caution as you need to know reference year

## how much "more important" does your target need to be than the species with the second greatest catch? Expressed as a ratio.
target_cutoff <- 1

## do you want to report revenue and lbs for the given target species? (dynamic)
# include_target <- TRUE
```

## Choose Year to Process

This parameter will get passed through all processing steps

```{r choose year}
# initialize variable to measure script runtime
alltime <- proc.time()

# choose year of data to process
process_year <- 2014

# choose first year of data processed for this set of pipeline runs
# if process_year > first_process_year, then lookback at the end of the prior year for tickets and VMS pings in step 4
first_process_year <- 2014

```

## Lookback Window

We enforce a "lookback window" when matching the VMS and fish tickets such that if there are more than X days [an option that can be changed] between successive tickets for the same vessel, we only include data for those X days. Look for the lookback window option in the master process script.

Create lookback object. Here is where the lookback window duration can be changed. Default is 7 days.

```{r lookback}
lookback_window <- 7 # in days
year_begin <- lubridate::ymd(paste0(process_year,"-01-01"), tz= "America/Los_Angeles")
year_end <- lubridate::ymd(paste0(process_year,"-12-31"), tz= "America/Los_Angeles")

if(process_year == first_process_year){
  lookback_begin <- year_begin
} else{
  lookback_begin <- year_begin - lubridate::days(lookback_window)
}
```

## Interpolation

Optionally, interpolate between geocoordinates for a consistent interval between VMS pings.

```{r interpolate}
interpolate_flag <- TRUE
```

# Step 1: Process Raw Fish Ticket Data

```{r step1,message=F,warning=F,child=here::here('process steps','01_process_fish_tickets.Rmd')}
```
```{r}
x<-proc.time()-alltime
```

**So far, this pipeline for `r process_year` VMS data has taken `r round(x[3]/60,2)` minutes to run.**

# Step 2: Report Vessel Lengths

```{r step2, message=F,warning=F,child=here::here('process steps','02_calculate_vessel_lengths.Rmd')}
```
```{r}
x<-proc.time()-alltime
```

**So far, this pipeline for `r process_year` VMS data has taken `r round(x[3]/60,2)` minutes to run.**

# Step 3: Process Raw VMS Data

```{r step3, message=F,warning=F,child=here::here('process steps','03_process_vms.Rmd')}
```
```{r}
x<-proc.time()-alltime
```

**So far, this pipeline for `r process_year` VMS data has taken `r round(x[3]/60,2)` minutes to run.**

# Step 4: Match VMS and Fish Ticket Data

```{r step5, message=F,warning=F,child=here::here('process steps','04_match_vms_fishtix.Rmd')}
```
```{r}
x<-proc.time()-alltime
# cat('This step for',process_year,'VMS data took',round(x[3]/60,2),'minutes to run.')
```

**So far, this pipeline for `r process_year` VMS data has taken `r round(x[3]/60,2)` minutes to run.**

# Step 5: Filter Matched Data by Speed and Proximity to Ports

```{r step5, message=F,warning=F,child=here::here('process steps','05_filter_matched_data.Rmd')}
```
```{r}
x<-proc.time()-alltime
```

**So far, this pipeline for `r process_year` VMS data has taken `r round(x[3]/60,2)` minutes to run.**

# Step 6: Optional: Interpolate VMS Pings

```{r step6, message=F,warning=F,child=if (interpolate_flag) here::here('process steps','optional_06_interpolate.Rmd')}
```
```{r}
x<-proc.time()-alltime
```

**This pipeline for `r process_year` VMS data took `r round(x[3]/60,2)` minutes to run.**
