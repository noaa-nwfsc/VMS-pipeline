---
title: "12_blh_example-ranked-persistence-map"
author: "Brooke Hawkins"
date: "`r Sys.Date()`"
output: 
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# import libraries
library(tidyverse)
```

Create a ranked persistence map, which will visualize the top x% of fishing activity based on the number of interpolated pings for a given year in a given grid cell.

For example, assume there are three grid cells with 10, 1, and 2 interpolated VMS pings in them in one year. Assume those same grid cells have 8, 8, and 0 interpolated VMS pings in them the following year.

| Year | Grid Cell | Number of pings |
|------|-----------|-----------------|
| 2013 | A         | 10              |
| 2013 | B         | 1               |
| 2013 | C         | 2               |
| 2014 | A         | 8               |
| 2014 | B         | 8               |
| 2014 | C         | 0               |

In 2013, there are 13 pings total. In 2014, there are 16 pings total.

Let's assign a cutoff of 75% - each year, we want to look at where 75% of the fishing activity occurred, based on the total pings that year.

-   For 2013, the 75% cutoff = 13 pings \* 0.75 = 9.75 pings. Let's round that to 10 pings.

-   For 2014, the 75% cutoff = 16 pings \* 0.75 = 12 pings.

| Year | Grid Cell | Number of pings | Annual pings | Threshold pings |
|------|-----------|-----------------|--------------|-----------------|
| 2013 | A         | 10              | 13           | 10              |
| 2013 | B         | 1               | 13           | 10              |
| 2013 | C         | 2               | 13           | 10              |
| 2014 | A         | 8               | 16           | 12              |
| 2014 | B         | 8               | 16           | 12              |
| 2014 | C         | 0               | 16           | 12              |

We will rank the grid cells for each year, calculate a cumulative sum, and see when we reach the 75% cutoff of fishing activity, and only include those grid cells within the persistence map. In the case of ties at the cutoff, we'll include ties.

| Year | Grid Cell | Number of pings | Annual pings | Annual threshold pings | Annual rank | Cumulative sum pings | Annual threshold pings |
|----|----|----|----|----|----|----|----|
| *2013* | *A* | *10* | *13* | *10* | *1* | *10* | *1* |
| 2013 | C | 2 | 13 | 10 | 2 | 12 | 0 |
| 2013 | B | 1 | 13 | 10 | 3 | 13 | 0 |
| *2014* | *A* | *8* | *16* | *12* | *1* | *8* | *1* |
| *2014* | *B* | *8* | *16* | *12* | *1* | *16* | *1* |
| 2014 | C | 0 | 16 | 12 | 2 | 16 | 0 |

In the ranked persistence map, grid cell A will include fishing activity for 2 years, B will include fishing for 1 year, and C will include fishing for 0 years. This example uses calendar years for simplicity's sake, but the plotting code will use crab years.

There is some complicated logic in here in the `case_when` statement and `include_in_map_tie_cocrrected` in order to include ties that reach the threshold, but exclude ties after the threshold has already been reached. If you want to understand the logic, then it's worth commenting the line that drops the lagged columns, and pay special attention to the ties in 2014 - how does the logic account for the tie with 8 pings that help reach the threshold, vs. 1 ping after the threshold is already reached?

```{r persistence-maps-coastal-ranked}
test_df <- tibble(year = c(2013, 2013, 2013, 2014, 2014, 2014, 2014, 2014, 2014),
                  grid_cell = c('A', 'B', 'C', 'A', 'B', 'C', 'D', 'E', 'F'),
                  n_pings = c(10, 2, 1, 8, 8, 8, 0, 1, 1))
# check out example dataframe
test_df

# assign a threshold cutoff
threshold_cutoff <- 0.75

# figure out annual pings
test_year_df <- test_df %>% group_by(year) %>%
  summarise(year_n_pings = sum(n_pings),
            year_cutoff_n_pings = ceiling(year_n_pings * threshold_cutoff))

# do the ranking and figure out which grid cells to include in the summary
ranked_test_df <- test_df %>% 
  left_join(test_year_df, by = 'year') %>% 
  group_by(year) %>%
  mutate(dense_rank_n_pings = dense_rank(n_pings * -1)) %>% 
  arrange(year, dense_rank_n_pings) %>%
  mutate(cumulative_n_pings = cumsum(n_pings),
         lag_cumulative_n_pings = lag(cumulative_n_pings),
         lag_n_pings = lag(n_pings),
         include_in_map = case_when(
           cumulative_n_pings <= year_cutoff_n_pings ~ TRUE,
           lag_cumulative_n_pings < year_cutoff_n_pings ~ TRUE,
           n_pings == lag_n_pings ~ TRUE,
           .default = FALSE
         )) %>%
  mutate(include_in_map_tie_corrected = coalesce(ifelse(!lag(include_in_map), FALSE, include_in_map), include_in_map)) %>% 
  select(-c(lag_cumulative_n_pings, lag_n_pings, include_in_map))

# view the result
ranked_test_df
```
